# 根据 CVE-ID 从 CVE 获取漏洞信息
from __future__ import annotations

import json
from pathlib import Path
from typing import Callable, Optional

import httpx

from summer_modules_ai.deepseek import DeepseekClient
from summer_modules_core.utils import write_dict_to_json_file
from summer_modules_core.web_request_utils import getUserAgent

from . import CVE_INFO_BASE_DIR, CVE_LOGGER

Translator = Callable[[str], str]


class CVEInfo:
    """CVE 信息查询与缓存工具。"""

    def __init__(
        self,
        deepseek_apikey: str | None = None,
        *,
        storage_dir: Path | None = None,
        translator: Optional[Translator] = None,
    ) -> None:
        """初始化 CVEInfo。

        Args:
            deepseek_apikey: DeepSeek 的 API Key，若提供则自动调用翻译。
            storage_dir: 自定义缓存目录，默认使用模块内置路径。
            translator: 自定义翻译函数，优先级高于 deepseek_apikey。
        """
        self.storage_dir = storage_dir or CVE_INFO_BASE_DIR
        self.storage_dir.mkdir(parents=True, exist_ok=True)
        if translator is not None:
            self._translate = translator
        elif deepseek_apikey:
            deepseek_client = DeepseekClient(deepseek_apikey)
            self._translate = deepseek_client.translate_text
        else:
            self._translate = lambda text: text

    def _get_vul_info_from_cve(self, cve_id: str, client: httpx.Client, headers: dict):
        """通过远端接口查询单个 CVE 的详细信息。"""
        resp = client.get(
            f"https://cveawg.mitre.org/api/cve/{cve_id}",
            # f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
            headers=headers,
        )
        if resp.status_code != 200:
            CVE_LOGGER.error(
                f"获取漏洞信息失败: {resp.text}, cve_id: {cve_id}, status_code: {resp.status_code}"
            )
            return None
        response_data_json = resp.json()
        cve_info = response_data_json

        descriptions = {}
        for item in cve_info["containers"]["cna"]["descriptions"]:
            if item["lang"] in ["en", "en-US"]:
                descriptions["en"] = item["value"]
            else:
                CVE_LOGGER.info(f"未知的语言: {item['lang']}")
                descriptions[item["lang"]] = item["value"]

        # 调用 deepseek 翻译 descriptions["en"] 的内容新增字段 descriptions["cn"]
        if descriptions.get("en"):
            descriptions["cn"] = self._translate(descriptions["en"])
        cve_info["containers"]["cna"]["descriptions"] = descriptions

        cve_info_base_dir = self.storage_dir / cve_id
        cve_info_base_dir.mkdir(parents=True, exist_ok=True)
        write_dict_to_json_file(cve_info, cve_info_base_dir / f"{cve_id}_cve.json")
        CVE_LOGGER.info(f"获取漏洞信息成功: {cve_id}")
        return cve_info

    def get_cve_info(self, cve_id: str, enable_local_search: bool = True) -> dict:
        """根据 CVE 编号获取漏洞详情。

        参数:
            cve_id: 目标 CVE 编号。
            enable_local_search: 是否优先使用本地缓存。

        返回:
            漏洞信息字典；查询失败时返回空字典。
        """
        if enable_local_search:
            cve_info_cve_dir = self.storage_dir / cve_id
            cve_info_cve_filepath = cve_info_cve_dir / f"{cve_id}_cve.json"
            if cve_info_cve_filepath.exists():
                CVE_LOGGER.debug(f"本地已存在漏洞信息: {cve_id}，从本地读取")
                with open(cve_info_cve_filepath, "r") as f:
                    return json.load(f)
        UA = getUserAgent()
        headers = {
            "user-agent": UA,
            "accept": "application/json, text/plain, */*",
            "accept-encoding": "gzip, deflate, br, zstd",
            "accept-language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
            "connection": "keep-alive",
            "dnt": "1",
            "host": "cve.mitre.org",
        }
        try:
            with httpx.Client(verify=False, timeout=20) as client:
                return self._get_vul_info_from_cve(cve_id, client, headers)
        except Exception as e:
            CVE_LOGGER.error(f"获取漏洞信息失败: cve_id: {cve_id}, error: {e}")
            return None

    def get_cve_description(self, cve_id: str, lang="cn") -> str:
        """根据 CVE 编号获取漏洞描述。

        参数:
            cve_id: 目标 CVE 编号，如 "CVE-2021-44228"。
            lang: 返回描述的语言，支持 "cn" 与 "en"。

        返回:
            漏洞描述字符串，获取失败时返回空字符串。
        """

        # 判断 CVE-ID 是否是 CVE-YYYY-NNNN 格式
        if not cve_id.startswith("CVE-"):
            CVE_LOGGER.warning(f"CVE-ID 不是标准格式：{cve_id}, 请检查")
            return ""
        # 去除首尾空格
        cve_id = cve_id.strip()

        def extract_description(info, language):
            """从 CVE 信息中提取指定语言的描述"""
            if language not in ["en", "cn"]:
                CVE_LOGGER.error(f"不支持的语言: {language}")
                return ""

            try:
                return info["containers"]["cna"]["descriptions"][language]
            except (KeyError, TypeError) as e:
                CVE_LOGGER.error(
                    f"提取漏洞描述失败: {cve_id}, 语言: {language}, 错误: {e}"
                )
                return ""

        cve_info = self.get_cve_info(cve_id) or {}
        if cve_info:
            return extract_description(cve_info, lang)

        CVE_LOGGER.error(f"无法获取漏洞信息: {cve_id}")
        return ""

    def test_get_cve_info_from_cve(self):
        cve_id = "CVE-2021-44228"
        cve_info = self.get_cve_info(cve_id)
        CVE_LOGGER.info(f"{cve_id}-cve_info: {cve_info}")

    def test_get_cve_description(self):
        cve_id = "CVE-2021-44228"
        cve_description = self.get_cve_description(cve_id)
        CVE_LOGGER.info(f"{cve_id}-cve_description: {cve_description}")
